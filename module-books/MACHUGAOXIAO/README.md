# 《码出高效 Java 开发手册》 杨冠宝（孤尽） 高海慧（鸣莎） 著

## 书评

## 目录

## 第 1 章 计算机基础
> 大道至简，盘古生其中。计算机的基础世界一切都是由 0 与 1 组成的。
### 1.1 走进 0 与 1 的世界
### 1.2 浮点数
### 1.3 字符集与乱码
### 1.4 CPU 与 内存
### 1.5 TCP/IP
### 1.6 信息安全
- XSS：Cross-Site Scropting，跨站脚本攻击。
- CSRF：Cross-Site Request Forgery，跨站请求伪造。
### 1.7 编程语言的发展


## 第 2 章 面向对象
> “一树一菩提，一‘门’一世界。”一切皆对象，万物有三问：我是谁？我从哪里来？我到哪里去？
### 2.1 OOP 理念
本书明确将“抽象”作为面向对象的特征之一，支持面向对象“四大特性”的说法。即：封装、继承、多态、抽象
### 2.2 初识 Java
### 2.3 类
#### 2.3.3 内部类
- 静态内部类
- 成员内部类
- 局部内部类
- 匿名内部类
```java
public class OuterClass {
    // 静态内部类
    static class StaticInnerClass {}
    // 成员内部类
    private class InstanceInnerClass {}

    public static void main(String... args) {
        // 匿名内部类
        new Thread() {}.start();        
        // 方法内部类
        class MethodClass {}
    }
}
```
#### 2.3.6 类关系
- 【继承】extends (is-a)
- 【实现】implements (can-do)
- 【组合】类是成员变量 (contains-a)：头只能是身体强组合的一部分，两者完全不可分，具有相同的生命周期。
- 【聚合】类是成员变量 (has-a)：小狗和狗绳之间是暂时的聚合关系，狗绳完全可以复用在另一条小狗上。
- 【依赖】import 类 (use-a)
#### 2.3.7 序列化
- Java 原生序列化
- Hessian 序列化
- JSON 序列化
### 2.4 方法
#### 2.4.2 参数
#### （1）入参保护
虽然“入参保护”被提及的频率和认知度远低于参数校验，但是其重要性却不能被忽略。入参保护实质上是对服务器提供方的保护，常见于批量接口。虽然批量接口能处理一批数据，但其处理能力并不是无限的，因此需要对入参的数据量进行判断和控制，如果超出处理能力，可以直接返回错误给客户端。某业务层发生过一个严重故障，就是由一个用户批量查询的接口导致的。虽然在 API 文档中约定了每次最多支持查询的用户 ID 个数，但在接口实现中没有做任何入参保护，导致当调用方传入万级的用户 ID 集合查询信息时，服务器内存被塞满，再无任何处理能力。
#### （2）参数校验
需要进行参数校验的场景：

- 调用频度低的方法。
- 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退或者错误，则得不偿失。
- 需要极高稳定性和可用性的方法。
- 对外提供的开放接口。
- 敏感权限入口。

不需要进行参数校验的场景：

- 极有可能被循环调用的方法。但在方法说明里必须注明外部参数校验。
- 底层调用频度较高的方法。参数错误不大可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以可以省略 DAO 的参数校验。
- 声明成 private 只会被自己代码调用的方法。如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。
### 2.5 重载
### 2.6 泛型
### 2.7 数据类型


## 第 3 章 代码风格
> 流水淡，碧天长，鸿雁成行。编码风格，简捷清爽，反引无限风光。
### 3.1 命名规约
#### 3.1.1 常量
```java
public enum CourseTypeEnum {
    /**
     * 允许官方和讲师创建和运营
     */
    VIDEO_COURSE(1, "录播课程"),

    /**
     * 只允许官方创建和运营。初始化必须设置合理的报名人数上限
     */
    LIVE_COURSE(2, "直播课程"),

    /**
     * 只允许官方创建和运营
     */
    OFFLINE_COURSE(3, "线下课程");

    private int seq;
    private String desc;

    CourseTypeEnum(int seq, String desc) {
        this.seq = seq;
        this.desc = desc;
    }

    public int getSeq() {
        return seq;
    }

    public String getDesc() {
        return desc;
    }
}
```
### 3.2 代码展示风格
### 3.3 代码注释


## 第 4 章 走进 JVM
> 云开方见日，潮尽炉峰出。揭开 JVM 的神秘面纱，探寻底层的实现原理。
### 4.1 字节码
### 4.2 类加载过程
在加载类时，使用的是 parent delegation model，译为双亲委派模型，这个译名有些不妥。如果意译的话，则译作“溯源委派加载模型”更为贴切。

低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类。如果低层次的类加载器想加载一个未知类，要非常礼貌地向上逐级询问：“请问，这个类已经加载了吗？”被询问的高层次类加载器会自问两个问题：第一，我是否已加载过此类？第二，如果没有，是否可以加载此类？只有当所有高层次类加载器在两个问题上的答案均为“否”时，才可以让当前类加载器加载这个未知类。

在学习了类加载器的实现机制后，知道双亲委派模型并非强制模型，用户可以自定义类加载器，在什么情况下需要自定义类加载器呢？

`（1）隔离加载类。`在某些框架内进行中间件于应用的模块隔离，把类加载到不同的环境。

`（2）修改类加载方式。`类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载。

`（3）扩展加载项。`比如从数据库、网络，甚至是电视机机顶盒进行加载。

`（4）防止源码泄露。`Java 代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。

### 4.3 内存布局
`1. Heap（堆区）`：-Xms256M -Xmx1024M：最小堆容量 最大堆容量。

`2. Metaspace（元空间）`：

3. JVM Stack（虚拟机栈）：

4. Native Method Stacks（本地方法栈）：

5. Program Counter Register（程序技术寄存器）：

### 4.4 对象实例化
### 4.5 垃圾回收


## 第 5 章 异常与日志
> “欲渡黄河冰塞川，将登太行雪满山。”系统运行，风云不测，睹始知终，秋去冬来，一叶落而知秋。
### 5.1 异常分类
### 5.2 try 代码块
### 5.3 异常的抛与接
### 5.4 日志
#### 5.4.1 日志规范

日志是有级别的。针对不同的场景，日志被分为五种不同的级别，按照重要程度由低到高排序。

- `DEBUG 级别日志` 记录对调试程序有帮助的信息。
- `INFO 级别日志` 用来记录程序运行现场，虽然此处并未发生错误。但是对排查其他错误具有指导意义。
- `WARN 级别日志` 也可以用来记录程序运行现场，但是更偏向于表明此处有出现潜在错误的可能。
- `ERROR 级别日志` 表明当前程序运行发生了错误，需要被关注。但是当前发生的错误，没有影响系统的继续运行。
- `FATAL 级别日志` 表明当前程序运行出现了严重的错误事件，并且将会导致程序中断。

## 第 6 章 数据结构与集合
> 廊腰缦回，檐牙高啄。纵使相同一砖一瓦，不同雕琢设计，亦生错落  有致的廊榭美景。数据结构的魅力也缘于此中道理。
### 6.1 数据结构
### 6.2 集合框架类
### 6.3 集合初始化
### 6.4 数据与集合
### 6.5 集合与泛型
`List<?>` 称为通配符集合。它可以接受任何类型的集合引用赋值，不能添加任何元素，但可以 remove 和 clear，并非 immutable 集合。`List<?>` 一般作为参数来接收外部的集合，或者返回一个不知道具体元素类型的集合。

`List<T>` 最大的问题时只能放置一种类型，如故宫随意转换类型的话，就是“破窗理论”，泛型就失去了类型安全的意义。如果需要放置多种受泛型约束的类型呢？JDK 的开发者顺应了民意，实现了 `<? extends T>` 与 `<? super T>` 两种语法，但是两者的区别非常微妙。简单来说，`<? extends T>` 是 Get First，适用于，消费集合元素为主的场景；`<? super T>` 是 Put First，适用于，生产集合元素为主的场景。

`<? extends T>` 可以赋值给任何 T 及 T 子类的集合，上界为 T，取出来的类型带有泛型限制，向上强制转型为 T。null 可以表示任何类型，所以除 null 外，任何元素都不得添加进 `<? extends T>` 集合内。

`<? super T>` 可以赋值给任何 T 及 T 的父类集合，下界为 T。在生活中，投票选举类似于 `<? super T>` 的操作。选举代表时，你只能往里投票，取数据时，根本不知道是谁的票，相当于泛型丢失。有人说，这只是一种生活场景，在系统设计中，很难有这样的情形。再举例说明一下，我们在填写对主管的年度评价时，提交后弱项再次访问之前的链接修改评价，就会被告知：“您已经完成对主管的年度反馈，谢谢参与。” extends 的场景是 put 功能受限，而 super 的场景是 get 功能受限。
### 6.6 元素的比较
#### 6.6.1 Comparable 和 Comparator
Java 找那个两个对象相比较的方法通常用在元素排序中，常用的两个接口分别是 Comparable 和 Comparator，前者是自己和自己比，可以看作是自营性质的比较器；后者是第三方比较器，可以看作是平台性质的比较器。
#### 6.6.2 hashCode 和 equals
hashCode 和 equals 用来标识对象，两个方法协同工作可用来判断两个对象是否相等。

Object 类定义中对 hashCode 和 equals 要求如下：

（1）如果两个对象的 equals 的结果是相等的，则两个对象的 hashCode 的返回结果也必须是相同的。

（2）任何时候覆写 equals，都必须同时覆写 hashCode。

### 6.7 fail-fast 机制
fail-fast 机制是集合世界中比较常见的错误检测机制，通常出现在遍历集合元素的过程中。

上课前，班长开始点名。刚点到一半，这时从教室外三三两两进来若干同学，同学们起哄：点错了！班长重新开始点名，点到中途，又出去几位同学，同学们又起哄说：点错了，班长又需要重新遍历，这就是 fail-fast 机制。它是一种对集合遍历操作时的错误检测机制，在遍历中途出现意料之外的修改时，通过 unchecked 异常暴力地反馈出来。这种机制经常出现在多线程环境下，当前线程会维护一个计数比较器，即 expectedModCount，记录已经修改的次数。在进入遍历前，会把实时修改次数 modCount 赋值给 expectedModCount，如果两个数据不相等，则抛出异常。java.util 下的所有集合类都是 fail-fast，而 concurrent包中的集合类都是 fail-safe。与 fail-fast 不同，fail-safe 对于刚才点名被频繁打断的情形，相当于班长直接拿出手机快速照相，然后根据照片点名，不再关心同学们的进进出出。

### 6.8 Map 类集合


## 第 7 章 并发与多线程
> 是以驷牡（sì mǔ ）异力，而六辔（pèi）如琴，并驾齐驱，而一毂（gǔ）统辐。行文如此，并发亦如此。
### 7.1 线程安全
### 7.2 什么是锁
### 7.3 线程同步
### 7.4 线程池
### 7.5 ThreadLocal
#### 7.5.1 引用类型
`强引用，即 Strong Reference`，最为常见。如 Object object = new Object(); 这样的变量声明和定义就后悔产生对该对象的强引用。只要对象有强引用指向，并且 GC Roots 可达，那么 Java 内存回收时，即使濒临内存耗尽，也不会回收该对象。

`软引用，即 Soft Reference`，引用力度弱于“强引用”，是用在非必需对象的场景。在即将 OOM 之前，垃圾回收器会把这些软引用指向的对象加入回收范围，以获得更多的内存空间，让程序能够继续健康运行。主要用来缓存服务器中间计算结果及不需要实时保存的用户行为等。

`弱引用，即 Weak Reference`，引用力度较前两者更弱，也是用来描述非必需对象的。如果弱引用指向的对象只存在弱引用这一条线路，则在下一次 YGC 时会被回收。由于 YGC 时间的不确定性，弱引用何时被回收也具有不确定性。弱引用主要用于指向某个易消失的对象，在强引用断开后，此引用不会劫持对象。调用 WeakReference.get() 可能返回 null，要注意空指针异常。

`虚引用，即 Phantom Reference`，是即若的一种引用关系，定义完成后，就无法通过该引用获取指向的对象。为一个对象设置虚引用的唯一目的就是希望能在这个对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，当垃圾回收时，如果发现存在虚引用，就会在回收对象内存前，把这个虚引用加入与之关联的引用队列中。

```java
House seller = new House();
// 永久有效 强引用
House buyer1 = seller;
// 内存不足 软引用
SoftReference<House> buyer2 = new SoftReference<>(seller);
// 再次 YGC 弱引用
WeakReference<House> buyer3 = new WeakReference<>(seller);
// 即时失效 虚引用
PhantomReference<House> buyer4 = new PhantomReference<>(seller, null);
```
## 第 8 章 单元测试
> 祸乱生于疏忽，单元测试先于交付。穿越暂时黑暗的时光隧道，才能迎来系统的曙光。
### 8.1 单元测试的基本原则
### 8.2 单元测试覆盖率
### 8.3 单元测试编写


## 第 9 章 代码规约
> 车同轨，书同文。手册源起，不忘初心，伯牙子期，琴瑟共鸣。
### 9.1 代码规约的意义
### 9.2 如何推动落地
### 9.3 手册纵览
### 9.4 聊聊成长